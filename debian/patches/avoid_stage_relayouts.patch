From c601ba6f579caeff77dfdf990bdb591fdcc467aa Mon Sep 17 00:00:00 2001
From: Daniel van Vugt <daniel.van.vugt@canonical.com>
Date: Tue, 7 May 2019 13:02:55 +0800
Subject: [PATCH 1/3] clutter/stage: Add an API for shallow relayouts

Where "shallow" means you can specify any actor instead of every relayout
having to start from the stage.

https://gitlab.gnome.org/GNOME/mutter/merge_requests/575
---
 clutter/clutter/clutter-stage-private.h |   3 +
 clutter/clutter/clutter-stage.c         | 104 ++++++++++++++++--------
 2 files changed, 72 insertions(+), 35 deletions(-)

Index: mutter/clutter/clutter/clutter-stage-private.h
===================================================================
--- mutter.orig/clutter/clutter/clutter-stage-private.h
+++ mutter/clutter/clutter/clutter-stage-private.h
@@ -136,6 +136,9 @@ void            _clutter_stage_presented
 
 GList *         _clutter_stage_peek_stage_views         (ClutterStage *stage);
 
+void            _clutter_stage_queue_actor_relayout     (ClutterStage *stage,
+                                                         ClutterActor *actor);
+
 G_END_DECLS
 
 #endif /* __CLUTTER_STAGE_PRIVATE_H__ */
Index: mutter/clutter/clutter/clutter-stage.c
===================================================================
--- mutter.orig/clutter/clutter/clutter-stage.c
+++ mutter/clutter/clutter/clutter-stage.c
@@ -136,6 +136,7 @@ struct _ClutterStagePrivate
 
   ClutterPlane current_clip_planes[4];
 
+  GList *pending_queue_relayouts;
   GList *pending_queue_redraws;
 
   CoglFramebuffer *active_framebuffer;
@@ -161,7 +162,6 @@ struct _ClutterStagePrivate
 
   int update_freeze_count;
 
-  guint relayout_pending       : 1;
   guint redraw_pending         : 1;
   guint is_fullscreen          : 1;
   guint is_cursor_visible      : 1;
@@ -1233,7 +1233,36 @@ _clutter_stage_needs_update (ClutterStag
 
   priv = stage->priv;
 
-  return priv->relayout_pending || priv->redraw_pending;
+  return priv->pending_queue_relayouts || priv->redraw_pending;
+}
+
+void
+_clutter_stage_queue_actor_relayout (ClutterStage *stage,
+                                     ClutterActor *actor)
+{
+  ClutterStagePrivate *priv = stage->priv;
+
+  if (priv->pending_queue_relayouts)
+    {
+      ClutterActor *first = priv->pending_queue_relayouts->data;
+
+      if (first == (ClutterActor *) stage)
+        {
+          return;
+        }
+      else if (actor == (ClutterActor *) stage)
+        {
+          g_list_free_full (priv->pending_queue_relayouts, g_object_unref);
+          priv->pending_queue_relayouts = NULL;
+        }
+    }
+  else
+    {
+      _clutter_stage_schedule_update (stage);
+    }
+
+  priv->pending_queue_relayouts =
+    g_list_prepend (priv->pending_queue_relayouts, g_object_ref (actor));
 }
 
 void
@@ -1241,41 +1270,49 @@ _clutter_stage_maybe_relayout (ClutterAc
 {
   ClutterStage *stage = CLUTTER_STAGE (actor);
   ClutterStagePrivate *priv = stage->priv;
-  gfloat natural_width, natural_height;
-  ClutterActorBox box = { 0, };
+  GList *stolen_list;
+  GList *elem;
+  int count = 0;
 
-  if (!priv->relayout_pending)
+  if (!priv->pending_queue_relayouts)
     return;
 
-  /* avoid reentrancy */
-  if (!CLUTTER_ACTOR_IN_RELAYOUT (stage))
-    {
-      priv->relayout_pending = FALSE;
-      priv->stage_was_relayout = TRUE;
+  stolen_list = priv->pending_queue_relayouts;
+  priv->pending_queue_relayouts = NULL;
+
+  CLUTTER_NOTE (ACTOR, ">>> Recomputing layout");
 
-      CLUTTER_NOTE (ACTOR, "Recomputing layout");
+  for (elem = stolen_list; elem != NULL; elem = elem->next)
+    {
+      ClutterActor *entry = CLUTTER_ACTOR (elem->data);
 
-      CLUTTER_SET_PRIVATE_FLAGS (stage, CLUTTER_IN_RELAYOUT);
+      if (CLUTTER_ACTOR_IN_RELAYOUT (entry) ||     /* avoid reentrancy */
+          clutter_actor_get_stage (entry) == NULL) /* avoid warnings */
+        continue;
 
-      natural_width = natural_height = 0;
-      clutter_actor_get_preferred_size (CLUTTER_ACTOR (stage),
-                                        NULL, NULL,
-                                        &natural_width, &natural_height);
+      if (elem == stolen_list && entry == actor)
+        CLUTTER_NOTE (ACTOR, "    Deep relayout of stage %s",
+                      _clutter_actor_get_debug_name (entry));
+      else
+        CLUTTER_NOTE (ACTOR, "    Shallow relayout of actor %s",
+                      _clutter_actor_get_debug_name (entry));
 
-      box.x1 = 0;
-      box.y1 = 0;
-      box.x2 = natural_width;
-      box.y2 = natural_height;
+      CLUTTER_SET_PRIVATE_FLAGS (entry, CLUTTER_IN_RELAYOUT);
 
-      CLUTTER_NOTE (ACTOR, "Allocating (0, 0 - %d, %d) for the stage",
-                    (int) natural_width,
-                    (int) natural_height);
+      clutter_actor_allocate_preferred_size (entry,
+                                             CLUTTER_ALLOCATION_NONE);
 
-      clutter_actor_allocate (CLUTTER_ACTOR (stage),
-                              &box, CLUTTER_ALLOCATION_NONE);
+      CLUTTER_UNSET_PRIVATE_FLAGS (entry, CLUTTER_IN_RELAYOUT);
 
-      CLUTTER_UNSET_PRIVATE_FLAGS (stage, CLUTTER_IN_RELAYOUT);
+      count++;
     }
+
+  CLUTTER_NOTE (ACTOR, "<<< Completed recomputing layout of %d subtrees", count);
+
+  g_list_free_full (stolen_list, g_object_unref);
+
+  if (count)
+    priv->stage_was_relayout = TRUE;
 }
 
 static void
@@ -1443,14 +1480,9 @@ static void
 clutter_stage_real_queue_relayout (ClutterActor *self)
 {
   ClutterStage *stage = CLUTTER_STAGE (self);
-  ClutterStagePrivate *priv = stage->priv;
   ClutterActorClass *parent_class;
 
-  if (!priv->relayout_pending)
-    {
-      _clutter_stage_schedule_update (stage);
-      priv->relayout_pending = TRUE;
-    }
+  _clutter_stage_queue_actor_relayout (stage, self);
 
   /* chain up */
   parent_class = CLUTTER_ACTOR_CLASS (clutter_stage_parent_class);
@@ -1913,6 +1945,9 @@ clutter_stage_dispose (GObject *object)
                     (GDestroyNotify) free_queue_redraw_entry);
   priv->pending_queue_redraws = NULL;
 
+  g_list_free_full (priv->pending_queue_relayouts, g_object_unref);
+  priv->pending_queue_relayouts = NULL;
+
   /* this will release the reference on the stage */
   stage_manager = clutter_stage_manager_get_default ();
   _clutter_stage_manager_remove_stage (stage_manager, stage);
@@ -2419,7 +2454,7 @@ clutter_stage_init (ClutterStage *self)
   priv->fog.z_near = 1.0;
   priv->fog.z_far  = 2.0;
 
-  priv->relayout_pending = TRUE;
+  _clutter_stage_queue_actor_relayout (self, CLUTTER_ACTOR (self));
 
   clutter_actor_set_reactive (CLUTTER_ACTOR (self), TRUE);
   clutter_stage_set_title (self, g_get_prgname ());
@@ -3792,10 +3827,9 @@ clutter_stage_ensure_redraw (ClutterStag
 
   priv = stage->priv;
 
-  if (!priv->relayout_pending && !priv->redraw_pending)
+  if (!priv->pending_queue_relayouts && !priv->redraw_pending)
     _clutter_stage_schedule_update (stage);
 
-  priv->relayout_pending = TRUE;
   priv->redraw_pending = TRUE;
 
   master_clock = _clutter_master_clock_get_default ();
Index: mutter/src/compositor/meta-window-group.c
===================================================================
--- mutter.orig/src/compositor/meta-window-group.c
+++ mutter/src/compositor/meta-window-group.c
@@ -199,6 +199,9 @@ meta_window_group_class_init (MetaWindow
 static void
 meta_window_group_init (MetaWindowGroup *window_group)
 {
+  ClutterActor *actor = CLUTTER_ACTOR (window_group);
+
+  clutter_actor_set_flags (actor, CLUTTER_ACTOR_NO_LAYOUT);
 }
 
 ClutterActor *
Index: mutter/clutter/clutter/clutter-actor.c
===================================================================
--- mutter.orig/clutter/clutter/clutter-actor.c
+++ mutter/clutter/clutter/clutter-actor.c
@@ -2896,9 +2896,25 @@ clutter_actor_real_queue_relayout (Clutt
   memset (priv->height_requests, 0,
           N_CACHED_SIZE_REQUESTS * sizeof (SizeRequest));
 
-  /* We need to go all the way up the hierarchy */
+  /* We may need to go all the way up the hierarchy */
   if (priv->parent != NULL)
-    _clutter_actor_queue_only_relayout (priv->parent);
+    {
+      if (priv->parent->flags & CLUTTER_ACTOR_NO_LAYOUT)
+        {
+          ClutterActor *stage = _clutter_actor_get_stage_internal (self);
+
+          _clutter_stage_queue_actor_relayout (CLUTTER_STAGE (stage), self);
+
+          /* The above might have invalidated the parent's paint volume if self
+           * has moved or resized. DnD seems to require this...
+           */
+          priv->parent->priv->needs_paint_volume_update = TRUE;
+        }
+      else
+        {
+          _clutter_actor_queue_only_relayout (priv->parent);
+        }
+    }
 }
 
 /**
